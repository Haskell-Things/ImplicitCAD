{-# LANGUAGE OverloadedStrings #-}

-- Implicit CAD. Copyright (C) 2011, Christopher Olah (chris@colah.ca)
-- Released under the GNU GPL, see LICENSE

module Graphics.Implicit.Export.PolylineFormats where

import Graphics.Implicit.Definitions

import Text.Printf (printf)

import Data.Text.Lazy (Text,unwords,pack)
import Data.Text.Lazy.Builder

import Text.Blaze.Svg.Renderer.Text (renderSvg)
import Text.Blaze.Svg
import Text.Blaze.Svg11 ((!),docTypeSvg,g,polyline,toValue)
import qualified Text.Blaze.Svg11.Attributes as A

import Data.List (foldl')

import Data.Monoid

import Prelude hiding (unwords)

svg :: [Polyline] -> Text
svg = renderSvg . svg11 . svg'
    where       
      svg11 content = docTypeSvg ! A.version "1.1" $ content
      -- The reason this isn't totally straightforwards is that svg has different coordinate system
      -- and we need to compute the requisite translation.
      svg' [] = mempty 
      -- When we have a known point, we can compute said transformation:
      svg' polylines@((start:_):_) = let (xmin, ymax) = foldl' (foldl' minmax) start polylines
                                     in thinBlueGroup $ mapM_ (poly xmin ymax) polylines
      -- Otherwise, if we don't have a point to start out with, skip this polyline:
      svg' ([]:rest) = svg' rest

      minmax (xa,ya) (xb,yb) = (min xa xb, max ya yb)
      
      poly xmin ymax line = polyline ! A.points pointList 
          where pointList = toValue $ unwords [pack $ show (x-xmin) ++ "," ++ show (ymax - y) | (x,y) <- line]
      -- Instead of setting styles on every polyline, we wrap the lines in a group element and set the styles on it:
      thinBlueGroup = g ! A.stroke "rgb(0,0,255)" ! A.strokeWidth "1" ! A.fill "none" -- $ obj

hacklabLaserGCode :: [Polyline] -> Text
hacklabLaserGCode polylines = toLazyText $ gcodeHeader <> mconcat (map interpretPolyline polylines) <> gcodeFooter
    where 
      gcodeHeader = mconcat [
                     "(generated by ImplicitCAD, based of hacklab wiki example)\n"
                    ,"M63 P0 (laser off)\n"
                    ,"G0 Z0.002 (laser off)\n"
                    ,"G21 (units=mm)\n"
                    ,"F400 (set feedrate)\n"
                    ,"M3 S1 (enable laser)\n\n"]
      gcodeFooter = mconcat [
                     "M5 (disable laser)\n"
                    ,"G00 X0.0 Y0.0 (move to 0)\n"
                    ,"M2 (end)"]
      gcodeXY :: â„2 -> Builder
      gcodeXY (x,y) = mconcat ["X", showF x, " Y", showF y]
                      
      showF = fromString . printf "%.4f"
              
      interpretPolyline (start:others) = mconcat [
                                          "G00 ", gcodeXY start
                                         ,"\nM62 P0 (laser on)\n"
                                         ,mconcat [ "G01 " <> gcodeXY point <> "\n" | point <- others]
                                         ,"M63 P0 (laser off)\n\n"
                                         ]
      interpretPolyline [] = mempty 